# This is a comprehensive code structure for building a Discord bot with multi-server support, game-specific verification flows (MLBB and BGMI), OAuth authentication for a dashboard, and automatic welcome DMs.
# The system is divided into:
# 1. Discord Bot (using discord.py) - Handles server joins, verifications, and DMs.
# 2. Web Dashboard (using Flask) - Multi-server dashboard with Discord OAuth for admin authentication.
# 3. Database (SQLite for simplicity, can upgrade to PostgreSQL) - Stores server configs, user verifications.

# Assumptions:
# - You have a Discord bot token, client ID, client secret for OAuth.
# - MLBB verification: Requires user to provide MLBB ID and server, simulate check (e.g., via API or dummy).
# - BGMI verification: Requires IGN (In-Game Name) and perhaps a code, simulate check.
# - Run bot and web app separately or together.
# - For production, use proper hosting, env vars for secrets.

# Setup instructions:
# 1. Install dependencies: pip install discord.py flask flask-sqlalchemy requests aiohttp
# 2. Set environment variables: DISCORD_TOKEN, CLIENT_ID, CLIENT_SECRET, REDIRECT_URI (e.g., http://localhost:5000/callback)
# 3. Run the bot: python bot.py
# 4. Run the dashboard: python dashboard.py

# --------------------
# database.py - Shared DB module
# --------------------
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class ServerConfig(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    guild_id = db.Column(db.BigInteger, unique=True)
    game_type = db.Column(db.String(50))  # 'MLBB' or 'BGMI'
    verification_channel_id = db.Column(db.BigInteger)
    welcome_message = db.Column(db.Text)

class UserVerification(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.BigInteger)
    guild_id = db.Column(db.BigInteger)
    game_data = db.Column(db.Text)  # JSON string for game-specific data
    verified = db.Column(db.Boolean, default=False)

# --------------------
# bot.py - Discord Bot Code
# --------------------
import discord
from discord.ext import commands
import json
import os
from database import db, ServerConfig, UserVerification

# Bot setup
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

# DB setup (SQLite for simplicity)
from flask import Flask
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///discord.db'
db.init_app(app)
with app.app_context():
    db.create_all()

@bot.event
async def on_ready():
    print(f'Bot logged in as {bot.user}')

@bot.event
async def on_member_join(member):
    # Find server config
    config = ServerConfig.query.filter_by(guild_id=member.guild.id).first()
    if config:
        # Send welcome DM with game-specific message
        welcome_msg = config.welcome_message or f"Welcome to {member.guild.name}! Please verify for {config.game_type}."
        await member.send(welcome_msg)

@bot.command(name='setup')
@commands.has_permissions(administrator=True)
async def setup(ctx, game_type: str, channel_id: int, welcome_msg: str):
    """Setup server: !setup MLBB 1234567890 "Welcome to MLBB verification!" """
    if game_type not in ['MLBB', 'BGMI']:
        await ctx.send("Invalid game type. Use MLBB or BGMI.")
        return
    
    config = ServerConfig.query.filter_by(guild_id=ctx.guild.id).first()
    if not config:
        config = ServerConfig(guild_id=ctx.guild.id)
    
    config.game_type = game_type
    config.verification_channel_id = channel_id
    config.welcome_message = welcome_msg
    db.session.add(config)
    db.session.commit()
    await ctx.send(f"Server setup for {game_type} with channel {channel_id}.")

@bot.command(name='verify')
async def verify(ctx, *args):
    config = ServerConfig.query.filter_by(guild_id=ctx.guild.id).first()
    if not config or ctx.channel.id != config.verification_channel_id:
        await ctx.send("Verification not setup or wrong channel.")
        return
    
    user_ver = UserVerification.query.filter_by(user_id=ctx.author.id, guild_id=ctx.guild.id).first()
    if not user_ver:
        user_ver = UserVerification(user_id=ctx.author.id, guild_id=ctx.guild.id)
    
    if config.game_type == 'MLBB':
        if len(args) < 2:
            await ctx.send("Usage: !verify MLBB_ID SERVER")
            return
        mlbb_id, server = args[0], args[1]
        # Simulate verification (replace with real API check)
        if verify_mlbb(mlbb_id, server):  # Define this function
            user_ver.game_data = json.dumps({'mlbb_id': mlbb_id, 'server': server})
            user_ver.verified = True
            db.session.add(user_ver)
            db.session.commit()
            await ctx.send("MLBB Verified!")
            # Assign role (optional: add role logic)
        else:
            await ctx.send("Verification failed.")
    
    elif config.game_type == 'BGMI':
        if len(args) < 1:
            await ctx.send("Usage: !verify IGN")
            return
        ign = args[0]
        # Simulate verification (replace with real check)
        if verify_bgmi(ign):  # Define this function
            user_ver.game_data = json.dumps({'ign': ign})
            user_ver.verified = True
            db.session.add(user_ver)
            db.session.commit()
            await ctx.send("BGMI Verified!")
        else:
            await ctx.send("Verification failed.")

# Dummy verification functions (replace with real APIs)
def verify_mlbb(mlbb_id, server):
    # e.g., requests.get(f"some_mlbb_api/{mlbb_id}/{server}")
    return True  # Simulate success

def verify_bgmi(ign):
    # e.g., requests.get(f"some_bgmi_api/{ign}")
    return True  # Simulate success

bot.run(os.getenv('DISCORD_TOKEN'))

# --------------------
# dashboard.py - Web Dashboard with OAuth
# --------------------
from flask import Flask, redirect, url_for, session, request, render_template_string
import requests
import os
from database import db, ServerConfig

app = Flask(__name__)
app.secret_key = 'super_secret_key'  # Change in production
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///discord.db'
db.init_app(app)

# OAuth endpoints
DISCORD_API = 'https://discord.com/api'
CLIENT_ID = os.getenv('CLIENT_ID')
CLIENT_SECRET = os.getenv('CLIENT_SECRET')
REDIRECT_URI = os.getenv('REDIRECT_URI')
OAUTH_URL = f'{DISCORD_API}/oauth2/authorize?client_id={CLIENT_ID}&redirect_uri={REDIRECT_URI}&response_type=code&scope=identify%20guilds'

@app.route('/')
def home():
    if 'access_token' not in session:
        return redirect(OAUTH_URL)
    return redirect(url_for('dashboard'))

@app.route('/callback')
def callback():
    code = request.args.get('code')
    data = {
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET,
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': REDIRECT_URI
    }
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}
    r = requests.post(f'{DISCORD_API}/oauth2/token', data=data, headers=headers)
    session['access_token'] = r.json()['access_token']
    
    # Get user guilds
    headers = {'Authorization': f'Bearer {session["access_token"]}'}
    guilds = requests.get(f'{DISCORD_API}/users/@me/guilds', headers=headers).json()
    session['guilds'] = [g['id'] for g in guilds if g['permissions'] & 0x8]  # Admin guilds
    return redirect(url_for('dashboard'))

@app.route('/dashboard')
def dashboard():
    if 'access_token' not in session:
        return redirect(OAUTH_URL)
    
    # Fetch configs for user's admin servers
    configs = ServerConfig.query.filter(ServerConfig.guild_id.in_(session['guilds'])).all()
    
    # Simple HTML template
    html = """
    <h1>Multi-Server Dashboard</h1>
    <table border="1">
        <tr><th>Guild ID</th><th>Game Type</th><th>Verification Channel</th><th>Welcome Message</th></tr>
        {% for config in configs %}
        <tr>
            <td>{{ config.guild_id }}</td>
            <td>{{ config.game_type }}</td>
            <td>{{ config.verification_channel_id }}</td>
            <td>{{ config.welcome_message }}</td>
        </tr>
        {% endfor %}
    </table>
    """
    return render_template_string(html, configs=configs)

if __name__ == '__main__':
    app.run(debug=True)